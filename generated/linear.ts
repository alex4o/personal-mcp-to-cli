#!/usr/bin/env bun
// @generated by mcps@0.0.0 on 2026-02-23T09:39:04.787Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "linear",
  "command": {
    "kind": "http",
    "url": "https://mcp.linear.app/mcp"
  },
  "source": {
    "kind": "local",
    "path": "<adhoc>"
  },
  "auth": "oauth",
  "oauthRedirectUrl": "http://megumin.serval-tone.ts.net:9801/callback",
  "description": "Linear"
} as const;
const embeddedSchemas = {
  "get_attachment": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Attachment ID"
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_attachment": {
    "type": "object",
    "properties": {
      "issue": {
        "type": "string",
        "description": "Issue ID or identifier (e.g., LIN-123)"
      },
      "base64Content": {
        "type": "string",
        "description": "Base64-encoded file content to upload"
      },
      "filename": {
        "type": "string",
        "description": "Filename for the upload (e.g., 'screenshot.png')"
      },
      "contentType": {
        "type": "string",
        "description": "MIME type for the upload (e.g., 'image/png', 'application/pdf')"
      },
      "title": {
        "description": "Optional title for the attachment",
        "type": "string"
      },
      "subtitle": {
        "description": "Optional subtitle for the attachment",
        "type": "string"
      }
    },
    "required": [
      "issue",
      "base64Content",
      "filename",
      "contentType"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "delete_attachment": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Attachment ID"
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_comments": {
    "type": "object",
    "properties": {
      "issueId": {
        "type": "string",
        "description": "Issue ID"
      }
    },
    "required": [
      "issueId"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_comment": {
    "type": "object",
    "properties": {
      "issueId": {
        "type": "string",
        "description": "Issue ID"
      },
      "parentId": {
        "description": "Parent comment ID (for replies)",
        "type": "string"
      },
      "body": {
        "type": "string",
        "description": "Content as Markdown"
      }
    },
    "required": [
      "issueId",
      "body"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_cycles": {
    "type": "object",
    "properties": {
      "teamId": {
        "type": "string",
        "description": "Team ID"
      },
      "type": {
        "description": "Filter: current, previous, next, or all",
        "type": "string",
        "enum": [
          "current",
          "previous",
          "next"
        ]
      }
    },
    "required": [
      "teamId"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_document": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Document ID or slug"
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_documents": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "query": {
        "description": "Search query",
        "type": "string"
      },
      "projectId": {
        "description": "Filter by project ID",
        "type": "string"
      },
      "initiativeId": {
        "description": "Filter by initiative ID",
        "type": "string"
      },
      "creatorId": {
        "description": "Filter by creator ID",
        "type": "string"
      },
      "createdAt": {
        "description": "Created after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "updatedAt": {
        "description": "Updated after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "includeArchived": {
        "default": false,
        "description": "Include archived items",
        "type": "boolean"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_document": {
    "type": "object",
    "properties": {
      "title": {
        "type": "string",
        "description": "Document title"
      },
      "content": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "issue": {
        "description": "Issue ID or identifier (e.g., LIN-123)",
        "type": "string"
      },
      "icon": {
        "description": "Icon emoji",
        "type": "string"
      },
      "color": {
        "description": "Hex color",
        "type": "string"
      }
    },
    "required": [
      "title"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "update_document": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Document ID or slug"
      },
      "title": {
        "description": "Document title",
        "type": "string"
      },
      "content": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "icon": {
        "description": "Icon emoji",
        "type": "string"
      },
      "color": {
        "description": "Hex color",
        "type": "string"
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "extract_images": {
    "type": "object",
    "properties": {
      "markdown": {
        "type": "string",
        "description": "Markdown content containing image references (e.g., issue description, comment body)"
      }
    },
    "required": [
      "markdown"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_issue": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Issue ID"
      },
      "includeRelations": {
        "default": false,
        "description": "Include blocking/related/duplicate relations",
        "type": "boolean"
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_issues": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "query": {
        "description": "Search issue title or description",
        "type": "string"
      },
      "team": {
        "description": "Team name or ID",
        "type": "string"
      },
      "state": {
        "description": "State type, name, or ID",
        "type": "string"
      },
      "cycle": {
        "description": "Cycle name, number, or ID",
        "type": "string"
      },
      "label": {
        "description": "Label name or ID",
        "type": "string"
      },
      "assignee": {
        "description": "User ID, name, email, or \"me\"",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "delegate": {
        "description": "Agent name or ID",
        "type": "string"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "priority": {
        "description": "0=None, 1=Urgent, 2=High, 3=Normal, 4=Low",
        "type": "number"
      },
      "parentId": {
        "description": "Parent issue ID",
        "type": "string"
      },
      "createdAt": {
        "description": "Created after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "updatedAt": {
        "description": "Updated after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "includeArchived": {
        "default": true,
        "description": "Include archived items",
        "type": "boolean"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_issue": {
    "type": "object",
    "properties": {
      "title": {
        "type": "string",
        "description": "Issue title"
      },
      "description": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "team": {
        "type": "string",
        "description": "Team name or ID"
      },
      "cycle": {
        "description": "Cycle name, number, or ID",
        "type": "string"
      },
      "milestone": {
        "description": "Milestone name or ID",
        "type": "string"
      },
      "priority": {
        "description": "0=None, 1=Urgent, 2=High, 3=Normal, 4=Low",
        "type": "number"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "state": {
        "description": "State type, name, or ID",
        "type": "string"
      },
      "assignee": {
        "description": "User ID, name, email, or \"me\"",
        "type": "string"
      },
      "delegate": {
        "description": "Agent name or ID",
        "type": "string"
      },
      "labels": {
        "description": "Label names or IDs",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "dueDate": {
        "description": "Due date (ISO format)",
        "type": "string"
      },
      "parentId": {
        "description": "Parent issue ID",
        "type": "string"
      },
      "estimate": {
        "description": "Issue estimate value",
        "type": "number"
      },
      "links": {
        "description": "Link attachments [{url, title}]",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "title": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "url",
            "title"
          ]
        }
      },
      "blocks": {
        "description": "Issue IDs/identifiers this blocks",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "blockedBy": {
        "description": "Issue IDs/identifiers blocking this",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "relatedTo": {
        "description": "Related issue IDs/identifiers",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "duplicateOf": {
        "description": "Duplicate of issue ID/identifier",
        "type": "string"
      }
    },
    "required": [
      "title",
      "team"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "update_issue": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Issue ID"
      },
      "title": {
        "description": "Issue title",
        "type": "string"
      },
      "description": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "team": {
        "description": "Team name or ID",
        "type": "string"
      },
      "milestone": {
        "description": "Milestone name or ID",
        "type": "string"
      },
      "priority": {
        "description": "0=None, 1=Urgent, 2=High, 3=Normal, 4=Low",
        "type": "number"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "state": {
        "description": "State type, name, or ID",
        "type": "string"
      },
      "cycle": {
        "description": "Cycle name, number, or ID",
        "type": "string"
      },
      "assignee": {
        "description": "User ID, name, email, or \"me\". Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "delegate": {
        "description": "Agent name or ID. Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "labels": {
        "description": "Label names or IDs",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "parentId": {
        "description": "Parent issue ID. Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "dueDate": {
        "description": "Due date (ISO format)",
        "type": "string"
      },
      "estimate": {
        "description": "Issue estimate value",
        "type": "number"
      },
      "links": {
        "description": "Link attachments [{url, title}]",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "title": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "url",
            "title"
          ]
        }
      },
      "blocks": {
        "description": "Issue IDs/identifiers this blocks. Replaces existing; omit to keep unchanged",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "blockedBy": {
        "description": "Issue IDs/identifiers blocking this. Replaces existing; omit to keep unchanged",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "relatedTo": {
        "description": "Related issue IDs/identifiers. Replaces existing; omit to keep unchanged",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "duplicateOf": {
        "description": "Duplicate of issue ID/identifier. Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_issue_statuses": {
    "type": "object",
    "properties": {
      "team": {
        "type": "string",
        "description": "Team name or ID"
      }
    },
    "required": [
      "team"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_issue_status": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Status ID"
      },
      "name": {
        "type": "string",
        "description": "Status name"
      },
      "team": {
        "type": "string",
        "description": "Team name or ID"
      }
    },
    "required": [
      "id",
      "name",
      "team"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_issue_labels": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "name": {
        "description": "Filter by name",
        "type": "string"
      },
      "team": {
        "description": "Team name or ID",
        "type": "string"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_issue_label": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Label name"
      },
      "description": {
        "description": "Label description",
        "type": "string"
      },
      "color": {
        "description": "Hex color code",
        "type": "string"
      },
      "teamId": {
        "description": "Team UUID (omit for workspace label)",
        "type": "string"
      },
      "parent": {
        "description": "Parent label group name",
        "type": "string"
      },
      "isGroup": {
        "default": false,
        "description": "Is label group (not directly applicable)",
        "type": "boolean"
      }
    },
    "required": [
      "name"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_projects": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "query": {
        "description": "Search project name",
        "type": "string"
      },
      "state": {
        "description": "State type, name, or ID",
        "type": "string"
      },
      "initiative": {
        "description": "Initiative name or ID",
        "type": "string"
      },
      "team": {
        "description": "Team name or ID",
        "type": "string"
      },
      "member": {
        "description": "User ID, name, email, or \"me\"",
        "type": "string"
      },
      "createdAt": {
        "description": "Created after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "updatedAt": {
        "description": "Updated after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "includeMilestones": {
        "default": false,
        "description": "Include milestones",
        "type": "boolean"
      },
      "includeMembers": {
        "default": false,
        "description": "Include project members",
        "type": "boolean"
      },
      "includeArchived": {
        "default": false,
        "description": "Include archived items",
        "type": "boolean"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_project": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Project name, ID, or slug"
      },
      "includeMilestones": {
        "default": false,
        "description": "Include milestones",
        "type": "boolean"
      },
      "includeMembers": {
        "default": false,
        "description": "Include project members",
        "type": "boolean"
      },
      "includeResources": {
        "default": false,
        "description": "Include resources (documents, links, attachments)",
        "type": "boolean"
      }
    },
    "required": [
      "query"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "save_project": {
    "type": "object",
    "properties": {
      "id": {
        "description": "Project ID. If provided, updates the existing project",
        "type": "string"
      },
      "name": {
        "description": "Project name (required when creating)",
        "type": "string"
      },
      "icon": {
        "description": "Icon emoji (e.g., :eagle:)",
        "type": "string"
      },
      "color": {
        "description": "Hex color",
        "type": "string"
      },
      "summary": {
        "description": "Short summary (max 255 chars)",
        "type": "string"
      },
      "description": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "state": {
        "description": "Project state",
        "type": "string"
      },
      "startDate": {
        "description": "Start date (ISO format)",
        "type": "string"
      },
      "targetDate": {
        "description": "Target date (ISO format)",
        "type": "string"
      },
      "priority": {
        "description": "0=None, 1=Urgent, 2=High, 3=Medium, 4=Low",
        "type": "integer",
        "minimum": 0,
        "maximum": 4
      },
      "team": {
        "description": "Team name or ID (required when creating)",
        "type": "string"
      },
      "labels": {
        "description": "Label names or IDs",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "lead": {
        "description": "User ID, name, email, or \"me\". Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "initiatives": {
        "description": "Initiative IDs or names",
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_project_labels": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "name": {
        "description": "Filter by name",
        "type": "string"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_milestones": {
    "type": "object",
    "properties": {
      "project": {
        "type": "string",
        "description": "Project name, ID, or slug"
      }
    },
    "required": [
      "project"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_milestone": {
    "type": "object",
    "properties": {
      "project": {
        "type": "string",
        "description": "Project name, ID, or slug"
      },
      "query": {
        "type": "string",
        "description": "Milestone name or ID"
      }
    },
    "required": [
      "project",
      "query"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_milestone": {
    "type": "object",
    "properties": {
      "project": {
        "type": "string",
        "description": "Project name, ID, or slug"
      },
      "name": {
        "type": "string",
        "description": "Milestone name"
      },
      "description": {
        "description": "Milestone description",
        "type": "string"
      },
      "targetDate": {
        "description": "Target completion date (ISO format)",
        "type": "string"
      }
    },
    "required": [
      "project",
      "name"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "update_milestone": {
    "type": "object",
    "properties": {
      "project": {
        "type": "string",
        "description": "Project name, ID, or slug"
      },
      "id": {
        "type": "string",
        "description": "Milestone name or ID"
      },
      "name": {
        "description": "Milestone name",
        "type": "string"
      },
      "description": {
        "description": "Milestone description",
        "type": "string"
      },
      "targetDate": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "description": "Target completion date (ISO format, null to remove)"
      }
    },
    "required": [
      "project",
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_teams": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "query": {
        "description": "Search query",
        "type": "string"
      },
      "includeArchived": {
        "default": false,
        "description": "Include archived items",
        "type": "boolean"
      },
      "createdAt": {
        "description": "Created after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "updatedAt": {
        "description": "Updated after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_team": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Team UUID, key, or name"
      }
    },
    "required": [
      "query"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_users": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "query": {
        "description": "Filter by name or email",
        "type": "string"
      },
      "team": {
        "description": "Team name or ID",
        "type": "string"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_user": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "User ID, name, email, or \"me\""
      }
    },
    "required": [
      "query"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "search_documentation": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Search query"
      },
      "page": {
        "default": 0,
        "description": "Page number",
        "type": "number"
      }
    },
    "required": [
      "query"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_initiatives": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "query": {
        "description": "Search initiative name",
        "type": "string"
      },
      "status": {
        "description": "Status of the initiative",
        "type": "string"
      },
      "owner": {
        "description": "User ID, name, email, or \"me\"",
        "type": "string"
      },
      "parentInitiative": {
        "description": "Parent initiative name or ID",
        "type": "string"
      },
      "createdAt": {
        "description": "Created after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "updatedAt": {
        "description": "Updated after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "includeArchived": {
        "default": false,
        "description": "Include archived items",
        "type": "boolean"
      },
      "includeProjects": {
        "default": false,
        "description": "Include projects",
        "type": "boolean"
      },
      "includeSubInitiatives": {
        "default": false,
        "description": "Include sub-initiatives",
        "type": "boolean"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_initiative": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Initiative ID or name"
      },
      "includeProjects": {
        "default": false,
        "description": "Include projects",
        "type": "boolean"
      },
      "includeSubInitiatives": {
        "default": false,
        "description": "Include sub-initiatives",
        "type": "boolean"
      }
    },
    "required": [
      "query"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "create_initiative": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Initiative name"
      },
      "summary": {
        "description": "Short summary (max 255 chars)",
        "type": "string"
      },
      "description": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "color": {
        "description": "Hex color",
        "type": "string"
      },
      "icon": {
        "description": "Icon emoji or name",
        "type": "string"
      },
      "status": {
        "description": "Initiative status (Planned, Active, Completed)",
        "type": "string"
      },
      "targetDate": {
        "description": "Target date (ISO format)",
        "type": "string"
      },
      "owner": {
        "description": "User ID, name, email, or \"me\"",
        "type": "string"
      }
    },
    "required": [
      "name"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "update_initiative": {
    "type": "object",
    "properties": {
      "id": {
        "type": "string",
        "description": "Initiative ID"
      },
      "name": {
        "description": "Initiative name",
        "type": "string"
      },
      "summary": {
        "description": "Short summary (max 255 chars)",
        "type": "string"
      },
      "description": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "color": {
        "description": "Hex color",
        "type": "string"
      },
      "icon": {
        "description": "Icon emoji or name",
        "type": "string"
      },
      "status": {
        "description": "Initiative status (Planned, Active, Completed)",
        "type": "string"
      },
      "targetDate": {
        "description": "Target date (ISO format)",
        "type": "string"
      },
      "owner": {
        "description": "User ID, name, email, or \"me\". Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "parentInitiative": {
        "description": "Parent initiative name or ID. Null to remove",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      }
    },
    "required": [
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_status_updates": {
    "type": "object",
    "properties": {
      "limit": {
        "default": 50,
        "description": "Max results (default 50, max 250)",
        "type": "number",
        "maximum": 250
      },
      "cursor": {
        "description": "Next page cursor",
        "type": "string"
      },
      "orderBy": {
        "default": "updatedAt",
        "description": "Sort: createdAt | updatedAt",
        "type": "string",
        "enum": [
          "createdAt",
          "updatedAt"
        ]
      },
      "type": {
        "type": "string",
        "enum": [
          "project",
          "initiative"
        ],
        "description": "Type of status update"
      },
      "id": {
        "description": "Status update ID - if provided, returns this specific update",
        "type": "string"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "initiative": {
        "description": "Initiative name or ID",
        "type": "string"
      },
      "user": {
        "description": "User ID, name, email, or \"me\"",
        "type": "string"
      },
      "createdAt": {
        "description": "Created after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "updatedAt": {
        "description": "Updated after: ISO-8601 date/duration (e.g., -P1D)",
        "type": "string"
      },
      "includeArchived": {
        "default": false,
        "description": "Include archived items",
        "type": "boolean"
      }
    },
    "required": [
      "type"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "save_status_update": {
    "type": "object",
    "properties": {
      "type": {
        "type": "string",
        "enum": [
          "project",
          "initiative"
        ],
        "description": "Type of status update"
      },
      "id": {
        "description": "Status update ID - if provided, updates this existing update",
        "type": "string"
      },
      "project": {
        "description": "Project name, ID, or slug",
        "type": "string"
      },
      "initiative": {
        "description": "Initiative name or ID",
        "type": "string"
      },
      "body": {
        "description": "Content as Markdown",
        "type": "string"
      },
      "health": {
        "description": "onTrack | atRisk | offTrack",
        "type": "string",
        "enum": [
          "onTrack",
          "atRisk",
          "offTrack"
        ]
      },
      "isDiffHidden": {
        "description": "Hide diff with previous update",
        "type": "boolean"
      }
    },
    "required": [
      "type"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "delete_status_update": {
    "type": "object",
    "properties": {
      "type": {
        "type": "string",
        "enum": [
          "project",
          "initiative"
        ],
        "description": "Type of status update"
      },
      "id": {
        "type": "string",
        "description": "Status update ID"
      }
    },
    "required": [
      "type",
      "id"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  }
} as const;
const embeddedName = "linear";
const embeddedDescription = "Linear";
const generatorInfo = "Generated by mcps@0.0.0 â€” https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "get-attachment",
    "description": "Retrieve an attachment's content by ID.",
    "usage": "get-attachment --id <id> [--raw <json>]",
    "flags": "--id <id> [--raw <json>]"
  },
  {
    "name": "create-attachment",
    "description": "Create a new attachment on a specific Linear issue by uploading base64-encoded content.",
    "usage": "create-attachment --issue <issue> --base64-content <base64-content> --filename <filename> --content-type <content-type> [--title <title>] [--raw <json>]",
    "flags": "--issue <issue> --base64-content <base64-content> --filename <filename> --content-type <content-type> [--title <title>] [--raw <json>]"
  },
  {
    "name": "delete-attachment",
    "description": "Delete an attachment by ID",
    "usage": "delete-attachment --id <id> [--raw <json>]",
    "flags": "--id <id> [--raw <json>]"
  },
  {
    "name": "list-comments",
    "description": "List comments for a specific Linear issue",
    "usage": "list-comments --issue-id <issue-id> [--raw <json>]",
    "flags": "--issue-id <issue-id> [--raw <json>]"
  },
  {
    "name": "create-comment",
    "description": "Create a comment on a specific Linear issue",
    "usage": "create-comment --issue-id <issue-id> [--parent-id <parent-id>] --body <body> [--raw <json>]",
    "flags": "--issue-id <issue-id> [--parent-id <parent-id>] --body <body> [--raw <json>]"
  },
  {
    "name": "list-cycles",
    "description": "Retrieve cycles for a specific Linear team",
    "usage": "list-cycles --team-id <team-id> [--type <type:current|previous|next>] [--raw <json>]",
    "flags": "--team-id <team-id> [--type <type:current|previous|next>] [--raw <json>]"
  },
  {
    "name": "get-document",
    "description": "Retrieve a Linear document by ID or slug",
    "usage": "get-document --id <id> [--raw <json>]",
    "flags": "--id <id> [--raw <json>]"
  },
  {
    "name": "list-documents",
    "description": "List documents in the user's Linear workspace",
    "usage": "list-documents [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--project-id <project-id>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--project-id <project-id>] [--raw <json>]"
  },
  {
    "name": "create-document",
    "description": "Create a new document in Linear",
    "usage": "create-document --title <title> [--content <content>] [--project <project>] [--issue <issue>] [--icon <icon>] [--raw <json>]",
    "flags": "--title <title> [--content <content>] [--project <project>] [--issue <issue>] [--icon <icon>] [--raw <json>]"
  },
  {
    "name": "update-document",
    "description": "Update an existing Linear document",
    "usage": "update-document --id <id> [--title <title>] [--content <content>] [--project <project>] [--icon <icon>] [--raw <json>]",
    "flags": "--id <id> [--title <title>] [--content <content>] [--project <project>] [--icon <icon>] [--raw <json>]"
  },
  {
    "name": "extract-images",
    "description": "Extract and fetch images from markdown content. Use this to view screenshots, diagrams, or other images embedded in Linear issues, comments, or documents. Pass the markdown content (e.g., issue description) and receive the images as viewable data.",
    "usage": "extract-images --markdown <markdown> [--raw <json>]",
    "flags": "--markdown <markdown> [--raw <json>]"
  },
  {
    "name": "get-issue",
    "description": "Retrieve detailed information about an issue by ID, including attachments and git branch name",
    "usage": "get-issue --id <id> [--include-relations <include-relations:true|false>] [--raw <json>]",
    "flags": "--id <id> [--include-relations <include-relations:true|false>] [--raw <json>]"
  },
  {
    "name": "list-issues",
    "description": "List issues in the user's Linear workspace. For my issues, use \"me\" as the assignee. Use \"null\" for no assignee.",
    "usage": "list-issues [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]"
  },
  {
    "name": "create-issue",
    "description": "Create a new Linear issue",
    "usage": "create-issue --title <title> [--description <description>] --team <team> [--cycle <cycle>] [--milestone <milestone>] [--raw <json>]",
    "flags": "--title <title> [--description <description>] --team <team> [--cycle <cycle>] [--milestone <milestone>] [--raw <json>]"
  },
  {
    "name": "update-issue",
    "description": "Update an existing Linear issue",
    "usage": "update-issue --id <id> [--title <title>] [--description <description>] [--team <team>] [--milestone <milestone>] [--raw <json>]",
    "flags": "--id <id> [--title <title>] [--description <description>] [--team <team>] [--milestone <milestone>] [--raw <json>]"
  },
  {
    "name": "list-issue-statuses",
    "description": "List available issue statuses in a Linear team",
    "usage": "list-issue-statuses --team <team> [--raw <json>]",
    "flags": "--team <team> [--raw <json>]"
  },
  {
    "name": "get-issue-status",
    "description": "Retrieve detailed information about an issue status in Linear by name or ID",
    "usage": "get-issue-status --id <id> --name <name> --team <team> [--raw <json>]",
    "flags": "--id <id> --name <name> --team <team> [--raw <json>]"
  },
  {
    "name": "list-issue-labels",
    "description": "List available issue labels in a Linear workspace or team",
    "usage": "list-issue-labels [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--team <team>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--team <team>] [--raw <json>]"
  },
  {
    "name": "create-issue-label",
    "description": "Create a new Linear issue label",
    "usage": "create-issue-label --name <name> [--description <description>] [--color <color>] [--team-id <team-id>] [--parent <parent>] [--raw <json>]",
    "flags": "--name <name> [--description <description>] [--color <color>] [--team-id <team-id>] [--parent <parent>] [--raw <json>]"
  },
  {
    "name": "list-projects",
    "description": "List projects in the user's Linear workspace",
    "usage": "list-projects [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--state <state>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--state <state>] [--raw <json>]"
  },
  {
    "name": "get-project",
    "description": "Retrieve details of a specific project in Linear",
    "usage": "get-project --query <query> [--include-milestones <include-milestones:true|false>] [--include-members <include-members:true|false>] [--include-resources <include-resources:true|false>] [--raw <json>]",
    "flags": "--query <query> [--include-milestones <include-milestones:true|false>] [--include-members <include-members:true|false>] [--include-resources <include-resources:true|false>] [--raw <json>]"
  },
  {
    "name": "save-project",
    "description": "Create or update a Linear project. If `id` is provided, updates the existing project; otherwise creates a new one. When creating, `name` and `team` are required.",
    "usage": "save-project [--id <id>] [--name <name>] [--icon <icon>] [--color <color>] [--summary <summary>] [--raw <json>]",
    "flags": "[--id <id>] [--name <name>] [--icon <icon>] [--color <color>] [--summary <summary>] [--raw <json>]"
  },
  {
    "name": "list-project-labels",
    "description": "List available project labels in the Linear workspace",
    "usage": "list-project-labels [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--raw <json>]"
  },
  {
    "name": "list-milestones",
    "description": "List all milestones in a Linear project",
    "usage": "list-milestones --project <project> [--raw <json>]",
    "flags": "--project <project> [--raw <json>]"
  },
  {
    "name": "get-milestone",
    "description": "Retrieve details of a specific milestone by ID or name",
    "usage": "get-milestone --project <project> --query <query> [--raw <json>]",
    "flags": "--project <project> --query <query> [--raw <json>]"
  },
  {
    "name": "create-milestone",
    "description": "Create a new milestone in a Linear project",
    "usage": "create-milestone --project <project> --name <name> [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]",
    "flags": "--project <project> --name <name> [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]"
  },
  {
    "name": "update-milestone",
    "description": "Update an existing milestone in a Linear project",
    "usage": "update-milestone --project <project> --id <id> [--name <name>] [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]",
    "flags": "--project <project> --id <id> [--name <name>] [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]"
  },
  {
    "name": "list-teams",
    "description": "List teams in the user's Linear workspace",
    "usage": "list-teams [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--include-archived <include-archived:true|false>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--include-archived <include-archived:true|false>] [--raw <json>]"
  },
  {
    "name": "get-team",
    "description": "Retrieve details of a specific Linear team",
    "usage": "get-team --query <query> [--raw <json>]",
    "flags": "--query <query> [--raw <json>]"
  },
  {
    "name": "list-users",
    "description": "Retrieve users in the Linear workspace",
    "usage": "list-users [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]"
  },
  {
    "name": "get-user",
    "description": "Retrieve details of a specific Linear user",
    "usage": "get-user --query <query> [--raw <json>]",
    "flags": "--query <query> [--raw <json>]"
  },
  {
    "name": "search-documentation",
    "description": "Search Linear's documentation to learn about features and usage",
    "usage": "search-documentation --query <query> [--page <page:number>] [--raw <json>]",
    "flags": "--query <query> [--page <page:number>] [--raw <json>]"
  },
  {
    "name": "list-initiatives",
    "description": "List initiatives in the user's Linear workspace",
    "usage": "list-initiatives [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--status <status>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--status <status>] [--raw <json>]"
  },
  {
    "name": "get-initiative",
    "description": "Retrieve detailed information about a specific initiative in Linear",
    "usage": "get-initiative --query <query> [--include-projects <include-projects:true|false>] [--include-sub-initiatives <include-sub-initiatives:true|false>] [--raw <json>]",
    "flags": "--query <query> [--include-projects <include-projects:true|false>] [--include-sub-initiatives <include-sub-initiatives:true|false>] [--raw <json>]"
  },
  {
    "name": "create-initiative",
    "description": "Create a new initiative in Linear",
    "usage": "create-initiative --name <name> [--summary <summary>] [--description <description>] [--color <color>] [--icon <icon>] [--raw <json>]",
    "flags": "--name <name> [--summary <summary>] [--description <description>] [--color <color>] [--icon <icon>] [--raw <json>]"
  },
  {
    "name": "update-initiative",
    "description": "Update an existing Linear initiative",
    "usage": "update-initiative --id <id> [--name <name>] [--summary <summary>] [--description <description>] [--color <color>] [--raw <json>]",
    "flags": "--id <id> [--name <name>] [--summary <summary>] [--description <description>] [--color <color>] [--raw <json>]"
  },
  {
    "name": "get-status-updates",
    "description": "List or get project/initiative status updates. Pass `id` to get a specific update, or filter to list.",
    "usage": "get-status-updates [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] --type <type:project|initiative> [--id <id>] [--raw <json>]",
    "flags": "[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] --type <type:project|initiative> [--id <id>] [--raw <json>]"
  },
  {
    "name": "save-status-update",
    "description": "Create or update a project/initiative status update. Omit `id` to create, provide `id` to update.",
    "usage": "save-status-update --type <type:project|initiative> [--id <id>] [--project <project>] [--initiative <initiative>] [--body <body>] [--raw <json>]",
    "flags": "--type <type:project|initiative> [--id <id>] [--project <project>] [--initiative <initiative>] [--body <body>] [--raw <json>]"
  },
  {
    "name": "delete-status-update",
    "description": "Delete (archive) a project or initiative status update.",
    "usage": "delete-status-update --type <type:project|initiative> --id <id> [--raw <json>]",
    "flags": "--type <type:project|initiative> --id <id> [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-02-23T09:39:04.787Z",
  "generator": {
    "name": "mcps",
    "version": "0.0.0"
  },
  "server": {
    "name": "linear",
    "source": {
      "kind": "local",
      "path": "<adhoc>"
    },
    "definition": {
      "name": "linear",
      "description": "Linear",
      "command": {
        "kind": "http",
        "url": "https://mcp.linear.app/mcp"
      },
      "auth": "oauth",
      "oauthRedirectUrl": "http://megumin.serval-tone.ts.net:9801/callback"
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "{\"name\":\"linear\",\"command\":{\"kind\":\"http\",\"url\":\"https://mcp.linear.app/mcp\"},\"source\":{\"kind\":\"local\",\"path\":\"<adhoc>\"},\"auth\":\"oauth\",\"oauthRedirectUrl\":\"http://megumin.serval-tone.ts.net:9801/callback\"}",
    "configPath": "<adhoc>",
    "runtime": "bun",
    "bundler": "bun",
    "outputPath": "./generated/linear.ts",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "get-attachment": "function get_attachment(id: string);",
  "create-attachment": "function create_attachment(issue: string, base64Content: string, filename: string, contentType: string, title?: string);",
  "delete-attachment": "function delete_attachment(id: string);",
  "list-comments": "function list_comments(issueId: string);",
  "create-comment": "function create_comment(issueId: string, parentId?: string, body: string);",
  "list-cycles": "function list_cycles(teamId: string, type?: \"current\" | \"previous\" | \"next\");",
  "get-document": "function get_document(id: string);",
  "list-documents": "function list_documents(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", query?: string, projectId?: string);",
  "create-document": "function create_document(title: string, content?: string, project?: string, issue?: string, icon?: string);",
  "update-document": "function update_document(id: string, title?: string, content?: string, project?: string, icon?: string);",
  "extract-images": "function extract_images(markdown: string);",
  "get-issue": "function get_issue(id: string, includeRelations?: boolean);",
  "list-issues": "function list_issues(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", query?: string, team?: string);",
  "create-issue": "function create_issue(title: string, description?: string, team: string, cycle?: string, milestone?: string);",
  "update-issue": "function update_issue(id: string, title?: string, description?: string, team?: string, milestone?: string);",
  "list-issue-statuses": "function list_issue_statuses(team: string);",
  "get-issue-status": "function get_issue_status(id: string, name: string, team: string);",
  "list-issue-labels": "function list_issue_labels(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", name?: string, team?: string);",
  "create-issue-label": "function create_issue_label(name: string, description?: string, color?: string, teamId?: string, parent?: string);",
  "list-projects": "function list_projects(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", query?: string, state?: string);",
  "get-project": "function get_project(query: string, includeMilestones?: boolean, includeMembers?: boolean, includeResources?: boolean);",
  "save-project": "function save_project(id?: string, name?: string, icon?: string, color?: string, summary?: string);",
  "list-project-labels": "function list_project_labels(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", name?: string);",
  "list-milestones": "function list_milestones(project: string);",
  "get-milestone": "function get_milestone(project: string, query: string);",
  "create-milestone": "function create_milestone(project: string, name: string, description?: string, targetDate?: string /* ISO 8601 */);",
  "update-milestone": "function update_milestone(project: string, id: string, name?: string, description?: string, targetDate?: unknown);",
  "list-teams": "function list_teams(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", query?: string, includeArchived?: boolean);",
  "get-team": "function get_team(query: string);",
  "list-users": "function list_users(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", query?: string, team?: string);",
  "get-user": "function get_user(query: string);",
  "search-documentation": "function search_documentation(query: string, page?: number);",
  "list-initiatives": "function list_initiatives(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", query?: string, status?: string);",
  "get-initiative": "function get_initiative(query: string, includeProjects?: boolean, includeSubInitiatives?: boolean);",
  "create-initiative": "function create_initiative(name: string, summary?: string, description?: string, color?: string, icon?: string);",
  "update-initiative": "function update_initiative(id: string, name?: string, summary?: string, description?: string, color?: string);",
  "get-status-updates": "function get_status_updates(limit?: number, cursor?: string, orderBy?: \"createdAt\" | \"updatedAt\", type: \"project\" | \"initiative\", id?: string);",
  "save-status-update": "function save_status_update(type: \"project\" | \"initiative\", id?: string, project?: string, initiative?: string, body?: string);",
  "delete-status-update": "function delete_status_update(type: \"project\" | \"initiative\", id: string);"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("get-attachment")
	.summary("get-attachment --id <id> [--raw <json>]")
	.description("Retrieve an attachment's content by ID.")
	.usage("--id <id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Attachment ID (example: example-id)")
	
	.alias("get_attachment")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
			const call = (proxy.getAttachment as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_attachment(id: \"example-id\")");

program
	.command("create-attachment")
	.summary("create-attachment --issue <issue> --base64-content <base64-content> --filename <filename> --content-type <content-type> [--title <title>] [--raw <json>]")
	.description("Create a new attachment on a specific Linear issue by uploading base64-encoded content.")
	.usage("--issue <issue> --base64-content <base64-content> --filename <filename> --content-type <content-type> [--title <title>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--issue <issue>", "Issue ID or identifier (e.g., LIN-123)")
	.requiredOption("--base64-content <base64-content>", "Base64-encoded file content to upload")
	.requiredOption("--filename <filename>", "Filename for the upload (e.g., 'screenshot.png')")
	.requiredOption("--content-type <content-type>", "MIME type for the upload (e.g., 'image/png', 'application/pdf')")
	.option("--title <title>", "Optional title for the attachment")
	.option("--subtitle <subtitle>", "Optional subtitle for the attachment")
	
	.alias("create_attachment")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.issue !== undefined) args.issue = cmdOpts.issue;
		if (cmdOpts.base64Content !== undefined) args.base64Content = cmdOpts.base64Content;
		if (cmdOpts.filename !== undefined) args.filename = cmdOpts.filename;
		if (cmdOpts.contentType !== undefined) args.contentType = cmdOpts.contentType;
		if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.subtitle !== undefined) args.subtitle = cmdOpts.subtitle;
			const call = (proxy.createAttachment as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_attachment(issue: \"value\", base64Content: \"val, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): subtitle" + '\n');

program
	.command("delete-attachment")
	.summary("delete-attachment --id <id> [--raw <json>]")
	.description("Delete an attachment by ID")
	.usage("--id <id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Attachment ID (example: example-id)")
	
	.alias("delete_attachment")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
			const call = (proxy.deleteAttachment as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.delete_attachment(id: \"example-id\")");

program
	.command("list-comments")
	.summary("list-comments --issue-id <issue-id> [--raw <json>]")
	.description("List comments for a specific Linear issue")
	.usage("--issue-id <issue-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--issue-id <issue-id>", "Issue ID (example: example-id)")
	
	.alias("list_comments")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.issueId !== undefined) args.issueId = cmdOpts.issueId;
			const call = (proxy.listComments as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_comments(issueId: \"example-id\")");

program
	.command("create-comment")
	.summary("create-comment --issue-id <issue-id> [--parent-id <parent-id>] --body <body> [--raw <json>]")
	.description("Create a comment on a specific Linear issue")
	.usage("--issue-id <issue-id> [--parent-id <parent-id>] --body <body> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--issue-id <issue-id>", "Issue ID (example: example-id)")
	.option("--parent-id <parent-id>", "Parent comment ID (for replies) (example: example-id)")
	.requiredOption("--body <body>", "Content as Markdown")
	
	.alias("create_comment")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.issueId !== undefined) args.issueId = cmdOpts.issueId;
		if (cmdOpts.parentId !== undefined) args.parentId = cmdOpts.parentId;
		if (cmdOpts.body !== undefined) args.body = cmdOpts.body;
			const call = (proxy.createComment as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_comment(issueId: \"example-id\", parentId: \"exam, ...)");

program
	.command("list-cycles")
	.summary("list-cycles --team-id <team-id> [--type <type:current|previous|next>] [--raw <json>]")
	.description("Retrieve cycles for a specific Linear team")
	.usage("--team-id <team-id> [--type <type:current|previous|next>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--team-id <team-id>", "Team ID (example: example-id)")
	.option("--type <type:current|previous|next>", "Filter: current, previous, next, or all (choices: current, previous, next; example: current)")
	
	.alias("list_cycles")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.teamId !== undefined) args.teamId = cmdOpts.teamId;
		if (cmdOpts.type !== undefined) args.type = cmdOpts.type;
			const call = (proxy.listCycles as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_cycles(teamId: \"example-id\", type: \"current\")");

program
	.command("get-document")
	.summary("get-document --id <id> [--raw <json>]")
	.description("Retrieve a Linear document by ID or slug")
	.usage("--id <id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Document ID or slug (example: example-id)")
	
	.alias("get_document")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
			const call = (proxy.getDocument as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_document(id: \"example-id\")");

program
	.command("list-documents")
	.summary("list-documents [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--project-id <project-id>] [--raw <json>]")
	.description("List documents in the user's Linear workspace")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--project-id <project-id>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--query <query>", "Search query")
	.option("--project-id <project-id>", "Filter by project ID (example: example-id)")
	.option("--initiative-id <initiative-id>", "Filter by initiative ID (example: example-id)")
	.option("--creator-id <creator-id>", "Filter by creator ID (example: example-id)")
	.option("--created-at <created-at:iso-8601>", "Created after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--updated-at <updated-at:iso-8601>", "Updated after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--include-archived <include-archived:true|false>", "Include archived items (default: false; example: false)", (value) => value !== 'false')
	
	.alias("list_documents")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.projectId !== undefined) args.projectId = cmdOpts.projectId;
		if (cmdOpts.initiativeId !== undefined) args.initiativeId = cmdOpts.initiativeId;
		if (cmdOpts.creatorId !== undefined) args.creatorId = cmdOpts.creatorId;
		if (cmdOpts.createdAt !== undefined) args.createdAt = cmdOpts.createdAt;
		if (cmdOpts.updatedAt !== undefined) args.updatedAt = cmdOpts.updatedAt;
		if (cmdOpts.includeArchived !== undefined) args.includeArchived = cmdOpts.includeArchived;
			const call = (proxy.listDocuments as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_documents(limit: 50, orderBy: \"createdAt\", proje, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (5): initiativeId, creatorId, createdAt, updatedAt, includeArchived" + '\n');

program
	.command("create-document")
	.summary("create-document --title <title> [--content <content>] [--project <project>] [--issue <issue>] [--icon <icon>] [--raw <json>]")
	.description("Create a new document in Linear")
	.usage("--title <title> [--content <content>] [--project <project>] [--issue <issue>] [--icon <icon>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--title <title>", "Document title")
	.option("--content <content>", "Content as Markdown")
	.option("--project <project>", "Project name, ID, or slug")
	.option("--issue <issue>", "Issue ID or identifier (e.g., LIN-123)")
	.option("--icon <icon>", "Icon emoji")
	.option("--color <color>", "Hex color")
	
	.alias("create_document")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.content !== undefined) args.content = cmdOpts.content;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.issue !== undefined) args.issue = cmdOpts.issue;
		if (cmdOpts.icon !== undefined) args.icon = cmdOpts.icon;
		if (cmdOpts.color !== undefined) args.color = cmdOpts.color;
			const call = (proxy.createDocument as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_document(title: \"value\")")
	.addHelpText('afterAll', () => '\n' + "// optional (1): color" + '\n');

program
	.command("update-document")
	.summary("update-document --id <id> [--title <title>] [--content <content>] [--project <project>] [--icon <icon>] [--raw <json>]")
	.description("Update an existing Linear document")
	.usage("--id <id> [--title <title>] [--content <content>] [--project <project>] [--icon <icon>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Document ID or slug (example: example-id)")
	.option("--title <title>", "Document title")
	.option("--content <content>", "Content as Markdown")
	.option("--project <project>", "Project name, ID, or slug")
	.option("--icon <icon>", "Icon emoji")
	.option("--color <color>", "Hex color")
	
	.alias("update_document")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.content !== undefined) args.content = cmdOpts.content;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.icon !== undefined) args.icon = cmdOpts.icon;
		if (cmdOpts.color !== undefined) args.color = cmdOpts.color;
			const call = (proxy.updateDocument as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.update_document(id: \"example-id\")")
	.addHelpText('afterAll', () => '\n' + "// optional (1): color" + '\n');

program
	.command("extract-images")
	.summary("extract-images --markdown <markdown> [--raw <json>]")
	.description("Extract and fetch images from markdown content. Use this to view screenshots, diagrams, or other images embedded in Linear issues, comments, or documents. Pass the markdown content (e.g., issue description) and receive the images as viewable data.")
	.usage("--markdown <markdown> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--markdown <markdown>", "Markdown content containing image references (e.g., issue description, comment body)")
	
	.alias("extract_images")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.markdown !== undefined) args.markdown = cmdOpts.markdown;
			const call = (proxy.extractImages as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.extract_images(markdown: \"value\")");

program
	.command("get-issue")
	.summary("get-issue --id <id> [--include-relations <include-relations:true|false>] [--raw <json>]")
	.description("Retrieve detailed information about an issue by ID, including attachments and git branch name")
	.usage("--id <id> [--include-relations <include-relations:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Issue ID (example: example-id)")
	.option("--include-relations <include-relations:true|false>", "Include blocking/related/duplicate relations (default: false; example: false)", (value) => value !== 'false')
	
	.alias("get_issue")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.includeRelations !== undefined) args.includeRelations = cmdOpts.includeRelations;
			const call = (proxy.getIssue as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_issue(id: \"example-id\", includeRelations: false)");

program
	.command("list-issues")
	.summary("list-issues [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]")
	.description("List issues in the user's Linear workspace. For my issues, use \"me\" as the assignee. Use \"null\" for no assignee.")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--query <query>", "Search issue title or description")
	.option("--team <team>", "Team name or ID")
	.option("--state <state>", "State type, name, or ID")
	.option("--cycle <cycle>", "Cycle name, number, or ID")
	.option("--label <label>", "Label name or ID")
	.option("--assignee <assignee>", "User ID, name, email, or \"me\"")
	.option("--delegate <delegate>", "Agent name or ID")
	.option("--project <project>", "Project name, ID, or slug")
	.option("--priority <priority:number>", "0=None, 1=Urgent, 2=High, 3=Normal, 4=Low (example: 1)", (value) => parseFloat(value))
	.option("--parent-id <parent-id>", "Parent issue ID (example: example-id)")
	.option("--created-at <created-at:iso-8601>", "Created after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--updated-at <updated-at:iso-8601>", "Updated after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--include-archived <include-archived:true|false>", "Include archived items (default: true; example: true)", (value) => value !== 'false')
	
	.alias("list_issues")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
		if (cmdOpts.state !== undefined) args.state = cmdOpts.state;
		if (cmdOpts.cycle !== undefined) args.cycle = cmdOpts.cycle;
		if (cmdOpts.label !== undefined) args.label = cmdOpts.label;
		if (cmdOpts.assignee !== undefined) args.assignee = cmdOpts.assignee;
		if (cmdOpts.delegate !== undefined) args.delegate = cmdOpts.delegate;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.priority !== undefined) args.priority = cmdOpts.priority;
		if (cmdOpts.parentId !== undefined) args.parentId = cmdOpts.parentId;
		if (cmdOpts.createdAt !== undefined) args.createdAt = cmdOpts.createdAt;
		if (cmdOpts.updatedAt !== undefined) args.updatedAt = cmdOpts.updatedAt;
		if (cmdOpts.includeArchived !== undefined) args.includeArchived = cmdOpts.includeArchived;
			const call = (proxy.listIssues as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_issues(limit: 50, orderBy: \"createdAt\")")
	.addHelpText('afterAll', () => '\n' + "// optional (11): state, cycle, label, assignee, delegate, ..." + '\n');

program
	.command("create-issue")
	.summary("create-issue --title <title> [--description <description>] --team <team> [--cycle <cycle>] [--milestone <milestone>] [--raw <json>]")
	.description("Create a new Linear issue")
	.usage("--title <title> [--description <description>] --team <team> [--cycle <cycle>] [--milestone <milestone>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--title <title>", "Issue title")
	.option("--description <description>", "Content as Markdown")
	.requiredOption("--team <team>", "Team name or ID")
	.option("--cycle <cycle>", "Cycle name, number, or ID")
	.option("--milestone <milestone>", "Milestone name or ID")
	.option("--priority <priority:number>", "0=None, 1=Urgent, 2=High, 3=Normal, 4=Low (example: 1)", (value) => parseFloat(value))
	.option("--project <project>", "Project name, ID, or slug")
	.option("--state <state>", "State type, name, or ID")
	.option("--assignee <assignee>", "User ID, name, email, or \"me\"")
	.option("--delegate <delegate>", "Agent name or ID")
	.option("--labels <labels:value1,value2>", "Label names or IDs (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--due-date <due-date:iso-8601>", "Due date (ISO format)")
	.option("--parent-id <parent-id>", "Parent issue ID (example: example-id)")
	.option("--estimate <estimate:number>", "Issue estimate value (example: 1)", (value) => parseFloat(value))
	.option("--links <links:value1,value2>", "Link attachments [{url, title}] (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--blocks <blocks:value1,value2>", "Issue IDs/identifiers this blocks (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--blocked-by <blocked-by:value1,value2>", "Issue IDs/identifiers blocking this (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--related-to <related-to:value1,value2>", "Related issue IDs/identifiers (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--duplicate-of <duplicate-of>", "Duplicate of issue ID/identifier")
	
	.alias("create_issue")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
		if (cmdOpts.cycle !== undefined) args.cycle = cmdOpts.cycle;
		if (cmdOpts.milestone !== undefined) args.milestone = cmdOpts.milestone;
		if (cmdOpts.priority !== undefined) args.priority = cmdOpts.priority;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.state !== undefined) args.state = cmdOpts.state;
		if (cmdOpts.assignee !== undefined) args.assignee = cmdOpts.assignee;
		if (cmdOpts.delegate !== undefined) args.delegate = cmdOpts.delegate;
		if (cmdOpts.labels !== undefined) args.labels = cmdOpts.labels;
		if (cmdOpts.dueDate !== undefined) args.dueDate = cmdOpts.dueDate;
		if (cmdOpts.parentId !== undefined) args.parentId = cmdOpts.parentId;
		if (cmdOpts.estimate !== undefined) args.estimate = cmdOpts.estimate;
		if (cmdOpts.links !== undefined) args.links = cmdOpts.links;
		if (cmdOpts.blocks !== undefined) args.blocks = cmdOpts.blocks;
		if (cmdOpts.blockedBy !== undefined) args.blockedBy = cmdOpts.blockedBy;
		if (cmdOpts.relatedTo !== undefined) args.relatedTo = cmdOpts.relatedTo;
		if (cmdOpts.duplicateOf !== undefined) args.duplicateOf = cmdOpts.duplicateOf;
			const call = (proxy.createIssue as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_issue(title: \"value\", team: \"value\")")
	.addHelpText('afterAll', () => '\n' + "// optional (14): priority, project, state, assignee, delegate, ..." + '\n');

program
	.command("update-issue")
	.summary("update-issue --id <id> [--title <title>] [--description <description>] [--team <team>] [--milestone <milestone>] [--raw <json>]")
	.description("Update an existing Linear issue")
	.usage("--id <id> [--title <title>] [--description <description>] [--team <team>] [--milestone <milestone>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Issue ID (example: example-id)")
	.option("--title <title>", "Issue title")
	.option("--description <description>", "Content as Markdown")
	.option("--team <team>", "Team name or ID")
	.option("--milestone <milestone>", "Milestone name or ID")
	.option("--priority <priority:number>", "0=None, 1=Urgent, 2=High, 3=Normal, 4=Low (example: 1)", (value) => parseFloat(value))
	.option("--project <project>", "Project name, ID, or slug")
	.option("--state <state>", "State type, name, or ID")
	.option("--cycle <cycle>", "Cycle name, number, or ID")
	.option("--assignee <assignee>", "User ID, name, email, or \"me\". Null to remove")
	.option("--delegate <delegate>", "Agent name or ID. Null to remove")
	.option("--labels <labels:value1,value2>", "Label names or IDs (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--parent-id <parent-id>", "Parent issue ID. Null to remove (example: example-id)")
	.option("--due-date <due-date:iso-8601>", "Due date (ISO format)")
	.option("--estimate <estimate:number>", "Issue estimate value (example: 1)", (value) => parseFloat(value))
	.option("--links <links:value1,value2>", "Link attachments [{url, title}] (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--blocks <blocks:value1,value2>", "Issue IDs/identifiers this blocks. Replaces existing; omit to keep unchanged (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--blocked-by <blocked-by:value1,value2>", "Issue IDs/identifiers blocking this. Replaces existing; omit to keep unchanged (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--related-to <related-to:value1,value2>", "Related issue IDs/identifiers. Replaces existing; omit to keep unchanged (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--duplicate-of <duplicate-of>", "Duplicate of issue ID/identifier. Null to remove")
	
	.alias("update_issue")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
		if (cmdOpts.milestone !== undefined) args.milestone = cmdOpts.milestone;
		if (cmdOpts.priority !== undefined) args.priority = cmdOpts.priority;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.state !== undefined) args.state = cmdOpts.state;
		if (cmdOpts.cycle !== undefined) args.cycle = cmdOpts.cycle;
		if (cmdOpts.assignee !== undefined) args.assignee = cmdOpts.assignee;
		if (cmdOpts.delegate !== undefined) args.delegate = cmdOpts.delegate;
		if (cmdOpts.labels !== undefined) args.labels = cmdOpts.labels;
		if (cmdOpts.parentId !== undefined) args.parentId = cmdOpts.parentId;
		if (cmdOpts.dueDate !== undefined) args.dueDate = cmdOpts.dueDate;
		if (cmdOpts.estimate !== undefined) args.estimate = cmdOpts.estimate;
		if (cmdOpts.links !== undefined) args.links = cmdOpts.links;
		if (cmdOpts.blocks !== undefined) args.blocks = cmdOpts.blocks;
		if (cmdOpts.blockedBy !== undefined) args.blockedBy = cmdOpts.blockedBy;
		if (cmdOpts.relatedTo !== undefined) args.relatedTo = cmdOpts.relatedTo;
		if (cmdOpts.duplicateOf !== undefined) args.duplicateOf = cmdOpts.duplicateOf;
			const call = (proxy.updateIssue as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.update_issue(id: \"example-id\")")
	.addHelpText('afterAll', () => '\n' + "// optional (15): priority, project, state, cycle, assignee, ..." + '\n');

program
	.command("list-issue-statuses")
	.summary("list-issue-statuses --team <team> [--raw <json>]")
	.description("List available issue statuses in a Linear team")
	.usage("--team <team> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--team <team>", "Team name or ID")
	
	.alias("list_issue_statuses")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
			const call = (proxy.listIssueStatuses as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_issue_statuses(team: \"value\")");

program
	.command("get-issue-status")
	.summary("get-issue-status --id <id> --name <name> --team <team> [--raw <json>]")
	.description("Retrieve detailed information about an issue status in Linear by name or ID")
	.usage("--id <id> --name <name> --team <team> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Status ID (example: example-id)")
	.requiredOption("--name <name>", "Status name")
	.requiredOption("--team <team>", "Team name or ID")
	
	.alias("get_issue_status")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
			const call = (proxy.getIssueStatus as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_issue_status(id: \"example-id\", name: \"value\", tea, ...)");

program
	.command("list-issue-labels")
	.summary("list-issue-labels [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--team <team>] [--raw <json>]")
	.description("List available issue labels in a Linear workspace or team")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--team <team>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--name <name>", "Filter by name")
	.option("--team <team>", "Team name or ID")
	
	.alias("list_issue_labels")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
			const call = (proxy.listIssueLabels as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_issue_labels(limit: 50, orderBy: \"createdAt\")");

program
	.command("create-issue-label")
	.summary("create-issue-label --name <name> [--description <description>] [--color <color>] [--team-id <team-id>] [--parent <parent>] [--raw <json>]")
	.description("Create a new Linear issue label")
	.usage("--name <name> [--description <description>] [--color <color>] [--team-id <team-id>] [--parent <parent>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--name <name>", "Label name")
	.option("--description <description>", "Label description")
	.option("--color <color>", "Hex color code")
	.option("--team-id <team-id>", "Team UUID (omit for workspace label) (example: example-id)")
	.option("--parent <parent>", "Parent label group name")
	.option("--is-group <is-group:true|false>", "Is label group (not directly applicable) (default: false; example: false)", (value) => value !== 'false')
	
	.alias("create_issue_label")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.color !== undefined) args.color = cmdOpts.color;
		if (cmdOpts.teamId !== undefined) args.teamId = cmdOpts.teamId;
		if (cmdOpts.parent !== undefined) args.parent = cmdOpts.parent;
		if (cmdOpts.isGroup !== undefined) args.isGroup = cmdOpts.isGroup;
			const call = (proxy.createIssueLabel as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_issue_label(name: \"value\", teamId: \"example-id\")")
	.addHelpText('afterAll', () => '\n' + "// optional (1): isGroup" + '\n');

program
	.command("list-projects")
	.summary("list-projects [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--state <state>] [--raw <json>]")
	.description("List projects in the user's Linear workspace")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--state <state>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--query <query>", "Search project name")
	.option("--state <state>", "State type, name, or ID")
	.option("--initiative <initiative>", "Initiative name or ID")
	.option("--team <team>", "Team name or ID")
	.option("--member <member>", "User ID, name, email, or \"me\"")
	.option("--created-at <created-at:iso-8601>", "Created after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--updated-at <updated-at:iso-8601>", "Updated after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--include-milestones <include-milestones:true|false>", "Include milestones (default: false; example: false)", (value) => value !== 'false')
	.option("--include-members <include-members:true|false>", "Include project members (default: false; example: false)", (value) => value !== 'false')
	.option("--include-archived <include-archived:true|false>", "Include archived items (default: false; example: false)", (value) => value !== 'false')
	
	.alias("list_projects")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.state !== undefined) args.state = cmdOpts.state;
		if (cmdOpts.initiative !== undefined) args.initiative = cmdOpts.initiative;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
		if (cmdOpts.member !== undefined) args.member = cmdOpts.member;
		if (cmdOpts.createdAt !== undefined) args.createdAt = cmdOpts.createdAt;
		if (cmdOpts.updatedAt !== undefined) args.updatedAt = cmdOpts.updatedAt;
		if (cmdOpts.includeMilestones !== undefined) args.includeMilestones = cmdOpts.includeMilestones;
		if (cmdOpts.includeMembers !== undefined) args.includeMembers = cmdOpts.includeMembers;
		if (cmdOpts.includeArchived !== undefined) args.includeArchived = cmdOpts.includeArchived;
			const call = (proxy.listProjects as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_projects(limit: 50, orderBy: \"createdAt\")")
	.addHelpText('afterAll', () => '\n' + "// optional (8): initiative, team, member, createdAt, updatedAt, ..." + '\n');

program
	.command("get-project")
	.summary("get-project --query <query> [--include-milestones <include-milestones:true|false>] [--include-members <include-members:true|false>] [--include-resources <include-resources:true|false>] [--raw <json>]")
	.description("Retrieve details of a specific project in Linear")
	.usage("--query <query> [--include-milestones <include-milestones:true|false>] [--include-members <include-members:true|false>] [--include-resources <include-resources:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Project name, ID, or slug")
	.option("--include-milestones <include-milestones:true|false>", "Include milestones (default: false; example: false)", (value) => value !== 'false')
	.option("--include-members <include-members:true|false>", "Include project members (default: false; example: false)", (value) => value !== 'false')
	.option("--include-resources <include-resources:true|false>", "Include resources (documents, links, attachments) (default: false; example: false)", (value) => value !== 'false')
	
	.alias("get_project")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.includeMilestones !== undefined) args.includeMilestones = cmdOpts.includeMilestones;
		if (cmdOpts.includeMembers !== undefined) args.includeMembers = cmdOpts.includeMembers;
		if (cmdOpts.includeResources !== undefined) args.includeResources = cmdOpts.includeResources;
			const call = (proxy.getProject as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_project(query: \"value\", includeMilestones: false, ...)");

program
	.command("save-project")
	.summary("save-project [--id <id>] [--name <name>] [--icon <icon>] [--color <color>] [--summary <summary>] [--raw <json>]")
	.description("Create or update a Linear project. If `id` is provided, updates the existing project; otherwise creates a new one. When creating, `name` and `team` are required.")
	.usage("[--id <id>] [--name <name>] [--icon <icon>] [--color <color>] [--summary <summary>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--id <id>", "Project ID. If provided, updates the existing project (example: example-id)")
	.option("--name <name>", "Project name (required when creating)")
	.option("--icon <icon>", "Icon emoji (e.g., :eagle:)")
	.option("--color <color>", "Hex color")
	.option("--summary <summary>", "Short summary (max 255 chars)")
	.option("--description <description>", "Content as Markdown")
	.option("--state <state>", "Project state")
	.option("--start-date <start-date:iso-8601>", "Start date (ISO format)")
	.option("--target-date <target-date:iso-8601>", "Target date (ISO format)")
	.option("--priority <priority:number>", "0=None, 1=Urgent, 2=High, 3=Medium, 4=Low (example: 1)", (value) => parseFloat(value))
	.option("--team <team>", "Team name or ID (required when creating)")
	.option("--labels <labels:value1,value2>", "Label names or IDs (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--lead <lead>", "User ID, name, email, or \"me\". Null to remove")
	.option("--initiatives <initiatives:value1,value2>", "Initiative IDs or names (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("save_project")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.icon !== undefined) args.icon = cmdOpts.icon;
		if (cmdOpts.color !== undefined) args.color = cmdOpts.color;
		if (cmdOpts.summary !== undefined) args.summary = cmdOpts.summary;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.state !== undefined) args.state = cmdOpts.state;
		if (cmdOpts.startDate !== undefined) args.startDate = cmdOpts.startDate;
		if (cmdOpts.targetDate !== undefined) args.targetDate = cmdOpts.targetDate;
		if (cmdOpts.priority !== undefined) args.priority = cmdOpts.priority;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
		if (cmdOpts.labels !== undefined) args.labels = cmdOpts.labels;
		if (cmdOpts.lead !== undefined) args.lead = cmdOpts.lead;
		if (cmdOpts.initiatives !== undefined) args.initiatives = cmdOpts.initiatives;
			const call = (proxy.saveProject as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.save_project(id: \"example-id\")")
	.addHelpText('afterAll', () => '\n' + "// optional (9): description, state, startDate, targetDate, priority, ..." + '\n');

program
	.command("list-project-labels")
	.summary("list-project-labels [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--raw <json>]")
	.description("List available project labels in the Linear workspace")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--name <name>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--name <name>", "Filter by name")
	
	.alias("list_project_labels")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
			const call = (proxy.listProjectLabels as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_project_labels(limit: 50, orderBy: \"createdAt\")");

program
	.command("list-milestones")
	.summary("list-milestones --project <project> [--raw <json>]")
	.description("List all milestones in a Linear project")
	.usage("--project <project> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project <project>", "Project name, ID, or slug")
	
	.alias("list_milestones")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
			const call = (proxy.listMilestones as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_milestones(project: \"value\")");

program
	.command("get-milestone")
	.summary("get-milestone --project <project> --query <query> [--raw <json>]")
	.description("Retrieve details of a specific milestone by ID or name")
	.usage("--project <project> --query <query> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project <project>", "Project name, ID, or slug")
	.requiredOption("--query <query>", "Milestone name or ID")
	
	.alias("get_milestone")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
			const call = (proxy.getMilestone as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_milestone(project: \"value\", query: \"value\")");

program
	.command("create-milestone")
	.summary("create-milestone --project <project> --name <name> [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]")
	.description("Create a new milestone in a Linear project")
	.usage("--project <project> --name <name> [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project <project>", "Project name, ID, or slug")
	.requiredOption("--name <name>", "Milestone name")
	.option("--description <description>", "Milestone description")
	.option("--target-date <target-date:iso-8601>", "Target completion date (ISO format)")
	
	.alias("create_milestone")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.targetDate !== undefined) args.targetDate = cmdOpts.targetDate;
			const call = (proxy.createMilestone as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_milestone(project: \"value\", name: \"value\")");

program
	.command("update-milestone")
	.summary("update-milestone --project <project> --id <id> [--name <name>] [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]")
	.description("Update an existing milestone in a Linear project")
	.usage("--project <project> --id <id> [--name <name>] [--description <description>] [--target-date <target-date:iso-8601>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project <project>", "Project name, ID, or slug")
	.requiredOption("--id <id>", "Milestone name or ID (example: example-id)")
	.option("--name <name>", "Milestone name")
	.option("--description <description>", "Milestone description")
	.option("--target-date <target-date:iso-8601>", "Target completion date (ISO format, null to remove)")
	
	.alias("update_milestone")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.targetDate !== undefined) args.targetDate = cmdOpts.targetDate;
			const call = (proxy.updateMilestone as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.update_milestone(project: \"value\", id: \"example-id\")");

program
	.command("list-teams")
	.summary("list-teams [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--include-archived <include-archived:true|false>] [--raw <json>]")
	.description("List teams in the user's Linear workspace")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--include-archived <include-archived:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--query <query>", "Search query")
	.option("--include-archived <include-archived:true|false>", "Include archived items (default: false; example: false)", (value) => value !== 'false')
	.option("--created-at <created-at:iso-8601>", "Created after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--updated-at <updated-at:iso-8601>", "Updated after: ISO-8601 date/duration (e.g., -P1D)")
	
	.alias("list_teams")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.includeArchived !== undefined) args.includeArchived = cmdOpts.includeArchived;
		if (cmdOpts.createdAt !== undefined) args.createdAt = cmdOpts.createdAt;
		if (cmdOpts.updatedAt !== undefined) args.updatedAt = cmdOpts.updatedAt;
			const call = (proxy.listTeams as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_teams(limit: 50, orderBy: \"createdAt\", includeAr, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (2): createdAt, updatedAt" + '\n');

program
	.command("get-team")
	.summary("get-team --query <query> [--raw <json>]")
	.description("Retrieve details of a specific Linear team")
	.usage("--query <query> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Team UUID, key, or name")
	
	.alias("get_team")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
			const call = (proxy.getTeam as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_team(query: \"value\")");

program
	.command("list-users")
	.summary("list-users [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]")
	.description("Retrieve users in the Linear workspace")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--team <team>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--query <query>", "Filter by name or email")
	.option("--team <team>", "Team name or ID")
	
	.alias("list_users")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.team !== undefined) args.team = cmdOpts.team;
			const call = (proxy.listUsers as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_users(limit: 50, orderBy: \"createdAt\")");

program
	.command("get-user")
	.summary("get-user --query <query> [--raw <json>]")
	.description("Retrieve details of a specific Linear user")
	.usage("--query <query> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "User ID, name, email, or \"me\"")
	
	.alias("get_user")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
			const call = (proxy.getUser as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_user(query: \"value\")");

program
	.command("search-documentation")
	.summary("search-documentation --query <query> [--page <page:number>] [--raw <json>]")
	.description("Search Linear's documentation to learn about features and usage")
	.usage("--query <query> [--page <page:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Search query")
	.option("--page <page:number>", "Page number (default: 0; example: 0)", (value) => parseFloat(value))
	
	.alias("search_documentation")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.page !== undefined) args.page = cmdOpts.page;
			const call = (proxy.searchDocumentation as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.search_documentation(query: \"value\", page: 0)");

program
	.command("list-initiatives")
	.summary("list-initiatives [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--status <status>] [--raw <json>]")
	.description("List initiatives in the user's Linear workspace")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] [--query <query>] [--status <status>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.option("--query <query>", "Search initiative name")
	.option("--status <status>", "Status of the initiative")
	.option("--owner <owner>", "User ID, name, email, or \"me\"")
	.option("--parent-initiative <parent-initiative>", "Parent initiative name or ID")
	.option("--created-at <created-at:iso-8601>", "Created after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--updated-at <updated-at:iso-8601>", "Updated after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--include-archived <include-archived:true|false>", "Include archived items (default: false; example: false)", (value) => value !== 'false')
	.option("--include-projects <include-projects:true|false>", "Include projects (default: false; example: false)", (value) => value !== 'false')
	.option("--include-sub-initiatives <include-sub-initiatives:true|false>", "Include sub-initiatives (default: false; example: false)", (value) => value !== 'false')
	
	.alias("list_initiatives")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.status !== undefined) args.status = cmdOpts.status;
		if (cmdOpts.owner !== undefined) args.owner = cmdOpts.owner;
		if (cmdOpts.parentInitiative !== undefined) args.parentInitiative = cmdOpts.parentInitiative;
		if (cmdOpts.createdAt !== undefined) args.createdAt = cmdOpts.createdAt;
		if (cmdOpts.updatedAt !== undefined) args.updatedAt = cmdOpts.updatedAt;
		if (cmdOpts.includeArchived !== undefined) args.includeArchived = cmdOpts.includeArchived;
		if (cmdOpts.includeProjects !== undefined) args.includeProjects = cmdOpts.includeProjects;
		if (cmdOpts.includeSubInitiatives !== undefined) args.includeSubInitiatives = cmdOpts.includeSubInitiatives;
			const call = (proxy.listInitiatives as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.list_initiatives(limit: 50, orderBy: \"createdAt\")")
	.addHelpText('afterAll', () => '\n' + "// optional (7): owner, parentInitiative, createdAt, updatedAt, includeArchived, ..." + '\n');

program
	.command("get-initiative")
	.summary("get-initiative --query <query> [--include-projects <include-projects:true|false>] [--include-sub-initiatives <include-sub-initiatives:true|false>] [--raw <json>]")
	.description("Retrieve detailed information about a specific initiative in Linear")
	.usage("--query <query> [--include-projects <include-projects:true|false>] [--include-sub-initiatives <include-sub-initiatives:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Initiative ID or name")
	.option("--include-projects <include-projects:true|false>", "Include projects (default: false; example: false)", (value) => value !== 'false')
	.option("--include-sub-initiatives <include-sub-initiatives:true|false>", "Include sub-initiatives (default: false; example: false)", (value) => value !== 'false')
	
	.alias("get_initiative")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.includeProjects !== undefined) args.includeProjects = cmdOpts.includeProjects;
		if (cmdOpts.includeSubInitiatives !== undefined) args.includeSubInitiatives = cmdOpts.includeSubInitiatives;
			const call = (proxy.getInitiative as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_initiative(query: \"value\", includeProjects: false, ...)");

program
	.command("create-initiative")
	.summary("create-initiative --name <name> [--summary <summary>] [--description <description>] [--color <color>] [--icon <icon>] [--raw <json>]")
	.description("Create a new initiative in Linear")
	.usage("--name <name> [--summary <summary>] [--description <description>] [--color <color>] [--icon <icon>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--name <name>", "Initiative name")
	.option("--summary <summary>", "Short summary (max 255 chars)")
	.option("--description <description>", "Content as Markdown")
	.option("--color <color>", "Hex color")
	.option("--icon <icon>", "Icon emoji or name")
	.option("--status <status>", "Initiative status (Planned, Active, Completed)")
	.option("--target-date <target-date:iso-8601>", "Target date (ISO format)")
	.option("--owner <owner>", "User ID, name, email, or \"me\"")
	
	.alias("create_initiative")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.summary !== undefined) args.summary = cmdOpts.summary;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.color !== undefined) args.color = cmdOpts.color;
		if (cmdOpts.icon !== undefined) args.icon = cmdOpts.icon;
		if (cmdOpts.status !== undefined) args.status = cmdOpts.status;
		if (cmdOpts.targetDate !== undefined) args.targetDate = cmdOpts.targetDate;
		if (cmdOpts.owner !== undefined) args.owner = cmdOpts.owner;
			const call = (proxy.createInitiative as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.create_initiative(name: \"value\")")
	.addHelpText('afterAll', () => '\n' + "// optional (3): status, targetDate, owner" + '\n');

program
	.command("update-initiative")
	.summary("update-initiative --id <id> [--name <name>] [--summary <summary>] [--description <description>] [--color <color>] [--raw <json>]")
	.description("Update an existing Linear initiative")
	.usage("--id <id> [--name <name>] [--summary <summary>] [--description <description>] [--color <color>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--id <id>", "Initiative ID (example: example-id)")
	.option("--name <name>", "Initiative name")
	.option("--summary <summary>", "Short summary (max 255 chars)")
	.option("--description <description>", "Content as Markdown")
	.option("--color <color>", "Hex color")
	.option("--icon <icon>", "Icon emoji or name")
	.option("--status <status>", "Initiative status (Planned, Active, Completed)")
	.option("--target-date <target-date:iso-8601>", "Target date (ISO format)")
	.option("--owner <owner>", "User ID, name, email, or \"me\". Null to remove")
	.option("--parent-initiative <parent-initiative>", "Parent initiative name or ID. Null to remove")
	
	.alias("update_initiative")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.summary !== undefined) args.summary = cmdOpts.summary;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.color !== undefined) args.color = cmdOpts.color;
		if (cmdOpts.icon !== undefined) args.icon = cmdOpts.icon;
		if (cmdOpts.status !== undefined) args.status = cmdOpts.status;
		if (cmdOpts.targetDate !== undefined) args.targetDate = cmdOpts.targetDate;
		if (cmdOpts.owner !== undefined) args.owner = cmdOpts.owner;
		if (cmdOpts.parentInitiative !== undefined) args.parentInitiative = cmdOpts.parentInitiative;
			const call = (proxy.updateInitiative as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.update_initiative(id: \"example-id\")")
	.addHelpText('afterAll', () => '\n' + "// optional (5): icon, status, targetDate, owner, parentInitiative" + '\n');

program
	.command("get-status-updates")
	.summary("get-status-updates [--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] --type <type:project|initiative> [--id <id>] [--raw <json>]")
	.description("List or get project/initiative status updates. Pass `id` to get a specific update, or filter to list.")
	.usage("[--limit <limit:number>] [--cursor <cursor>] [--order-by <order-by:createdAt|updatedAt>] --type <type:project|initiative> [--id <id>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--limit <limit:number>", "Max results (default 50, max 250) (default: 50; example: 50)", (value) => parseFloat(value))
	.option("--cursor <cursor>", "Next page cursor")
	.option("--order-by <order-by:createdAt|updatedAt>", "Sort: createdAt | updatedAt (choices: createdAt, updatedAt; default: updatedAt; example: createdAt)")
	.requiredOption("--type <type:project|initiative>", "Type of status update (choices: project, initiative; example: project)")
	.option("--id <id>", "Status update ID - if provided, returns this specific update (example: example-id)")
	.option("--project <project>", "Project name, ID, or slug")
	.option("--initiative <initiative>", "Initiative name or ID")
	.option("--user <user>", "User ID, name, email, or \"me\"")
	.option("--created-at <created-at:iso-8601>", "Created after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--updated-at <updated-at:iso-8601>", "Updated after: ISO-8601 date/duration (e.g., -P1D)")
	.option("--include-archived <include-archived:true|false>", "Include archived items (default: false; example: false)", (value) => value !== 'false')
	
	.alias("get_status_updates")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.cursor !== undefined) args.cursor = cmdOpts.cursor;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
		if (cmdOpts.type !== undefined) args.type = cmdOpts.type;
		if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.initiative !== undefined) args.initiative = cmdOpts.initiative;
		if (cmdOpts.user !== undefined) args.user = cmdOpts.user;
		if (cmdOpts.createdAt !== undefined) args.createdAt = cmdOpts.createdAt;
		if (cmdOpts.updatedAt !== undefined) args.updatedAt = cmdOpts.updatedAt;
		if (cmdOpts.includeArchived !== undefined) args.includeArchived = cmdOpts.includeArchived;
			const call = (proxy.getStatusUpdates as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.get_status_updates(limit: 50, orderBy: \"createdAt\", t, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (6): project, initiative, user, createdAt, updatedAt, ..." + '\n');

program
	.command("save-status-update")
	.summary("save-status-update --type <type:project|initiative> [--id <id>] [--project <project>] [--initiative <initiative>] [--body <body>] [--raw <json>]")
	.description("Create or update a project/initiative status update. Omit `id` to create, provide `id` to update.")
	.usage("--type <type:project|initiative> [--id <id>] [--project <project>] [--initiative <initiative>] [--body <body>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--type <type:project|initiative>", "Type of status update (choices: project, initiative; example: project)")
	.option("--id <id>", "Status update ID - if provided, updates this existing update (example: example-id)")
	.option("--project <project>", "Project name, ID, or slug")
	.option("--initiative <initiative>", "Initiative name or ID")
	.option("--body <body>", "Content as Markdown")
	.option("--health <health:onTrack|atRisk|offTrack>", "onTrack | atRisk | offTrack (choices: onTrack, atRisk, offTrack; example: onTrack)")
	.option("--is-diff-hidden <is-diff-hidden:true|false>", "Hide diff with previous update (example: true)", (value) => value !== 'false')
	
	.alias("save_status_update")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.type !== undefined) args.type = cmdOpts.type;
		if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.project !== undefined) args.project = cmdOpts.project;
		if (cmdOpts.initiative !== undefined) args.initiative = cmdOpts.initiative;
		if (cmdOpts.body !== undefined) args.body = cmdOpts.body;
		if (cmdOpts.health !== undefined) args.health = cmdOpts.health;
		if (cmdOpts.isDiffHidden !== undefined) args.isDiffHidden = cmdOpts.isDiffHidden;
			const call = (proxy.saveStatusUpdate as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.save_status_update(type: \"project\", id: \"example-id\")")
	.addHelpText('afterAll', () => '\n' + "// optional (2): health, isDiffHidden" + '\n');

program
	.command("delete-status-update")
	.summary("delete-status-update --type <type:project|initiative> --id <id> [--raw <json>]")
	.description("Delete (archive) a project or initiative status update.")
	.usage("--type <type:project|initiative> --id <id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--type <type:project|initiative>", "Type of status update (choices: project, initiative; example: project)")
	.requiredOption("--id <id>", "Status update ID (example: example-id)")
	
	.alias("delete_status_update")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.type !== undefined) args.type = cmdOpts.type;
		if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
			const call = (proxy.deleteStatusUpdate as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call linear.delete_status_update(type: \"project\", id: \"example-id\")");

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('â€” ' + embeddedDescription);
	const plainTitle = embeddedName + ' â€” ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
